<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ™ºèƒ½è§’è‰²æ‰®æ¼”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            min-width: 100px;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .content {
            padding: 40px 20px;
        }

        .section-title {
            text-align: center;
            font-size: 2rem;
            color: #333;
            margin-bottom: 30px;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .character-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-color: #4facfe;
        }

        .character-avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: white;
            margin: 0 auto 20px;
        }

        .character-name {
            font-size: 1.4rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .character-category {
            color: #4facfe;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
        }

        .character-description {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 20px;
            height: 60px;
            overflow: hidden;
        }

        .character-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .tag {
            background: #e9ecef;
            color: #495057;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .chat-btn {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .chat-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        /* èŠå¤©æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
        }

        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4facfe;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: #28a745;
        }

        .message-content {
            background: white;
            padding: 12px 16px;
            border-radius: 15px;
            max-width: 70%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .message.user .message-content {
            background: #4facfe;
            color: white;
        }

        .input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #eee;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
        }

        .message-input:focus {
            border-color: #4facfe;
        }

        .send-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
        }

        .send-btn:hover {
            background: #3a8bfe;
        }

        .voice-btn {
            background: linear-gradient(135deg, #fa709a, #fee140);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .voice-btn:hover {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            transform: scale(1.05);
        }

        .voice-btn.recording {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-status {
            text-align: center;
            padding: 8px;
            font-size: 0.9rem;
            color: #666;
            background: #f8f9fa;
            border-radius: 10px;
            margin-top: 10px;
        }

        .audio-controls {
            margin-top: 8px;
            text-align: center;
        }

        .play-audio-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-audio-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .characters-grid {
                grid-template-columns: 1fr;
            }
            
            .stats {
                flex-direction: column;
                gap: 15px;
            }
            
            .modal-content {
                width: 95%;
                height: 90vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <h1>ğŸ¤– AIæ™ºèƒ½è§’è‰²æ‰®æ¼”</h1>
            <p>ä¸å†å²åäººã€ç§‘å­¦å®¶ã€æ–‡å­¦å®¶è¿›è¡Œæ·±åº¦å¯¹è¯ï¼Œæ¢ç´¢ä¸åŒçš„äººç”Ÿæ™ºæ…§ä¸çŸ¥è¯†å®è—</p>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-number" id="characterCount">{{ character_count }}</span>
                    <span class="stat-label">ç²¾é€‰è§’è‰²</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">âˆ</span>
                    <span class="stat-label">å¯¹è¯æ¬¡æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">24/7</span>
                    <span class="stat-label">åœ¨çº¿æœåŠ¡</span>
                </div>
            </div>
        </div>

        <!-- å†…å®¹åŒºåŸŸ -->
        <div class="content">
            <h2 class="section-title">é€‰æ‹©æ‚¨çš„å¯¹è¯ä¼™ä¼´</h2>
            
            <div class="characters-grid">
                {% for character in characters %}
                <div class="character-card" onclick="startChat('{{ character.id }}', '{{ character.name }}')">
                    <div class="character-avatar">
                        {% if character.category == 'philosophy' %}ğŸ§ 
                        {% elif character.category == 'science' %}ğŸ”¬
                        {% elif character.category == 'literature' %}ğŸ“š
                        {% elif character.category == 'fiction' %}ğŸ­
                        {% else %}ğŸ‘¤
                        {% endif %}
                    </div>
                    <div class="character-name">{{ character.name }}</div>
                    <div class="character-category">
                        {% if character.category == 'philosophy' %}å“²å­¦å®¶
                        {% elif character.category == 'science' %}ç§‘å­¦å®¶
                        {% elif character.category == 'literature' %}æ–‡å­¦å®¶
                        {% elif character.category == 'fiction' %}è™šæ‹Ÿè§’è‰²
                        {% else %}å…¶ä»–
                        {% endif %}
                    </div>
                    <div class="character-description">{{ character.background[:100] }}...</div>
                    <div class="character-tags">
                        {% for tag in character.tags[:3] %}
                        <span class="tag">{{ tag }}</span>
                        {% endfor %}
                    </div>
                    <button class="chat-btn" onclick="event.stopPropagation(); startChat('{{ character.id }}', '{{ character.name }}')">
                        ğŸ’¬ å¼€å§‹å¯¹è¯
                    </button>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>

    <!-- èŠå¤©æ¨¡æ€æ¡† -->
    <div class="modal" id="chatModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">ä¸ AIåŠ©æ‰‹ å¯¹è¯</div>
                <button class="close-btn" onclick="closeChat()">&times;</button>
            </div>
            <div class="chat-container" id="chatContainer">
                <div class="loading" id="loadingMessage">æ­£åœ¨åˆå§‹åŒ–å¯¹è¯...</div>
            </div>
            <div class="input-area">
                <div class="input-group">
                    <input type="text" class="message-input" id="messageInput" placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯æˆ–ç‚¹å‡»è¯­éŸ³æŒ‰é’®..." maxlength="500">
                    <button class="voice-btn" id="voiceBtn" onclick="toggleVoiceRecording()">ğŸ¤</button>
                    <button class="send-btn" onclick="sendMessage()">å‘é€</button>
                </div>
                <div class="voice-status" id="voiceStatus" style="display: none;">
                    <span id="voiceStatusText">å‡†å¤‡å½•éŸ³</span>
                </div>
                <div class="voice-test-area" style="text-align: center; margin-top: 10px;">
                    <button class="voice-test-btn" onclick="testRecording()" style="
                        background: linear-gradient(135deg, #28a745, #20c997);
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 0.9rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    ">
                        ğŸ”§ æµ‹è¯•å½•éŸ³
                    </button>
                    <div id="testResult" style="margin-top: 8px; font-size: 0.8rem; color: #666;"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        let socket = null;
        let currentCharacter = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let audioPlayer = null;

        function startChat(characterId, characterName) {
            console.log('å¼€å§‹å¯¹è¯:', characterId, characterName);
            
            currentCharacter = characterId;
            document.getElementById('modalTitle').textContent = `ä¸ ${characterName} å¯¹è¯`;
            document.getElementById('chatContainer').innerHTML = '<div class="loading">æ­£åœ¨è¿æ¥...</div>';
            document.getElementById('chatModal').classList.add('show');
            
            // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
            if (!audioPlayer) {
                audioPlayer = document.createElement('audio');
                audioPlayer.controls = false;
            }
            
            // åˆå§‹åŒ–Socket.IOè¿æ¥
            if (socket) {
                socket.disconnect();
            }
            
            socket = io();
            
            socket.on('connect', () => {
                console.log('Socketè¿æ¥æˆåŠŸ');
                document.getElementById('chatContainer').innerHTML = `
                    <div class="message">
                        <div class="message-avatar">${getCharacterEmoji(characterId)}</div>
                        <div class="message-content">ä½ å¥½ï¼æˆ‘æ˜¯${characterName}ï¼Œå¾ˆé«˜å…´ä¸ä½ äº¤æµã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ</div>
                    </div>
                `;
            });
            
            socket.on('chat_response', (data) => {
                console.log('æ”¶åˆ°AIå›å¤:', data);
                addMessage(data.response, 'ai', data.character.name, data.audio_url);
            });
            
            socket.on('voice_message', (data) => {
                console.log('æ”¶åˆ°è¯­éŸ³æ¶ˆæ¯å¤„ç†ç»“æœ:', data);
            });
            
            socket.on('recognition_result', (data) => {
                console.log('è¯­éŸ³è¯†åˆ«ç»“æœ:', data.text);
                document.getElementById('messageInput').value = data.text;
                updateVoiceStatus('è¯†åˆ«å®Œæˆ: ' + data.text);
            });
            
            socket.on('ai_response', (data) => {
                console.log('AIæ–‡å­—å›å¤:', data.text);
                addMessage(data.text, 'ai', characterName);
            });
            
            socket.on('tts_result', (data) => {
                console.log('æ”¶åˆ°è¯­éŸ³åˆæˆç»“æœ');
                if (data.audio) {
                    playAudio(data.audio);
                }
            });
            
            socket.on('status', (data) => {
                updateVoiceStatus(data.message);
            });
            
            socket.on('error', (data) => {
                console.error('Socketé”™è¯¯:', data);
                addMessage('æŠ±æ­‰ï¼Œå‡ºç°äº†ä¸€äº›é—®é¢˜ï¼š' + data.message, 'system');
                updateVoiceStatus('é”™è¯¯: ' + data.message);
            });
            
            socket.on('disconnect', () => {
                console.log('Socketè¿æ¥æ–­å¼€');
            });
        }

        function closeChat() {
            document.getElementById('chatModal').classList.remove('show');
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !socket || !currentCharacter) {
                return;
            }
            
            // æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
            addMessage(message, 'user');
            input.value = '';
            
            // å‘é€åˆ°æœåŠ¡å™¨
            socket.emit('chat_message', {
                message: message,
                character_id: currentCharacter
            });
        }

        function addMessage(content, sender, characterName = '', audioUrl = null) {
            const container = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            let avatar = '';
            if (sender === 'user') {
                avatar = 'ğŸ‘¤';
            } else if (sender === 'system') {
                avatar = 'âš ï¸';
            } else {
                avatar = getCharacterEmoji(currentCharacter);
            }
            
            let audioControls = '';
            if (sender === 'ai' && audioUrl) {
                audioControls = `
                    <div class="audio-controls">
                        <button class="play-audio-btn" onclick="playAudio('${audioUrl}')">
                            ğŸ”Š æ’­æ”¾è¯­éŸ³
                        </button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    ${content}
                    ${audioControls}
                </div>
            `;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            // å¦‚æœæ˜¯AIæ¶ˆæ¯ä¸”æœ‰éŸ³é¢‘ï¼Œè‡ªåŠ¨æ’­æ”¾
            if (sender === 'ai' && audioUrl) {
                setTimeout(() => {
                    playAudio(audioUrl);
                }, 500);
            }
        }

        async function toggleVoiceRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                await stopRecording();
            }
        }

        async function startRecording() {
            try {
                console.log('å¼€å§‹å½•éŸ³...');
                updateVoiceStatus('æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...');
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 44100,  // ä½¿ç”¨æ›´é«˜çš„é‡‡æ ·ç‡
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                // å°è¯•ä½¿ç”¨WAVæ ¼å¼ï¼Œå¦‚æœä¸æ”¯æŒåˆ™ä½¿ç”¨WebM
                let mimeType = 'audio/wav';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm;codecs=opus';
                }
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('å½•éŸ³æ•°æ®å—å¤§å°:', event.data.size);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    await processRecording();
                };
                
                // æ¯100msæ”¶é›†ä¸€æ¬¡æ•°æ®ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„éŸ³é¢‘æ•°æ®
                mediaRecorder.start(100);
                isRecording = true;
                
                // æ›´æ–°UI
                const voiceBtn = document.getElementById('voiceBtn');
                voiceBtn.classList.add('recording');
                voiceBtn.textContent = 'ğŸ›‘';
                
                updateVoiceStatus('æ­£åœ¨å½•éŸ³... è¯·è¯´è¯ï¼Œå†æ¬¡ç‚¹å‡»åœæ­¢');
                
                // æ·»åŠ æœ€å°å½•éŸ³æ—¶é—´æ£€æŸ¥
                setTimeout(() => {
                    if (isRecording) {
                        updateVoiceStatus('ç»§ç»­å½•éŸ³ä¸­... è¯·ç¡®ä¿è¯´è¯å£°éŸ³æ¸…æ™°');
                    }
                }, 1000);
                
            } catch (error) {
                console.error('å½•éŸ³å¤±è´¥:', error);
                updateVoiceStatus('æ— æ³•è®¿é—®éº¦å…‹é£: ' + error.message);
            }
        }

        async function stopRecording() {
            if (mediaRecorder && isRecording) {
                console.log('åœæ­¢å½•éŸ³...');
                
                mediaRecorder.stop();
                isRecording = false;
                
                // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
                if (mediaRecorder.stream) {
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
                
                // æ›´æ–°UI
                const voiceBtn = document.getElementById('voiceBtn');
                voiceBtn.classList.remove('recording');
                voiceBtn.textContent = 'ğŸ¤';
                
                updateVoiceStatus('å¤„ç†å½•éŸ³ä¸­...');
            }
        }

        async function processRecording() {
            try {
                if (audioChunks.length === 0) {
                    updateVoiceStatus('å½•éŸ³æ•°æ®ä¸ºç©ºï¼Œè¯·é‡æ–°å½•éŸ³');
                    return;
                }
                
                const audioBlob = new Blob(audioChunks, { 
                    type: mediaRecorder.mimeType || 'audio/webm' 
                });
                
                console.log('å½•éŸ³å¤„ç†å®Œæˆ');
                console.log('- æ•°æ®å—æ•°é‡:', audioChunks.length);
                console.log('- æ€»å¤§å°:', audioBlob.size, 'å­—èŠ‚');
                console.log('- MIMEç±»å‹:', audioBlob.type);
                
                // æ£€æŸ¥å½•éŸ³å¤§å°
                if (audioBlob.size < 1000) {
                    updateVoiceStatus('å½•éŸ³æ—¶é—´å¤ªçŸ­ï¼Œè¯·é‡æ–°å½•éŸ³');
                    return;
                }
                
                if (audioBlob.size > 10 * 1024 * 1024) {
                    updateVoiceStatus('å½•éŸ³æ–‡ä»¶è¿‡å¤§ï¼Œè¯·å½•åˆ¶è¾ƒçŸ­çš„éŸ³é¢‘');
                    return;
                }
                
                updateVoiceStatus('æ­£åœ¨å¤„ç†éŸ³é¢‘...');
                
                // å¦‚æœæ˜¯WebMæ ¼å¼ï¼Œå°è¯•è½¬æ¢ä¸ºWAV
                let finalBlob = audioBlob;
                if (audioBlob.type.includes('webm')) {
                    console.log('æ£€æµ‹åˆ°WebMæ ¼å¼ï¼Œå°è¯•è½¬æ¢...');
                    try {
                        finalBlob = await convertWebMToWAV(audioBlob);
                        console.log('éŸ³é¢‘è½¬æ¢æˆåŠŸï¼Œæ–°å¤§å°:', finalBlob.size);
                    } catch (convertError) {
                        console.warn('éŸ³é¢‘è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', convertError);
                        // ç»§ç»­ä½¿ç”¨åŸå§‹æ ¼å¼
                    }
                }
                
                // è½¬æ¢ä¸ºbase64
                const reader = new FileReader();
                reader.onloadend = () => {
                    const audioBase64 = reader.result;
                    console.log('å‘é€è¯­éŸ³æ•°æ®åˆ°æœåŠ¡å™¨...');
                    console.log('Base64é•¿åº¦:', audioBase64.length);
                    
                    // å‘é€åˆ°æœåŠ¡å™¨è¿›è¡Œè¯­éŸ³è¯†åˆ«
                    socket.emit('voice_message', {
                        audio: audioBase64
                    });
                    
                    updateVoiceStatus('æ­£åœ¨è¯†åˆ«è¯­éŸ³...');
                };
                
                reader.onerror = () => {
                    updateVoiceStatus('éŸ³é¢‘æ•°æ®è¯»å–å¤±è´¥');
                };
                
                reader.readAsDataURL(finalBlob);
                
            } catch (error) {
                console.error('å¤„ç†å½•éŸ³å¤±è´¥:', error);
                updateVoiceStatus('å¤„ç†å½•éŸ³å¤±è´¥: ' + error.message);
            }
        }

        // ç®€å•çš„WebMåˆ°WAVè½¬æ¢å‡½æ•°
        async function convertWebMToWAV(webmBlob) {
            return new Promise((resolve, reject) => {
                try {
                    // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // è¯»å–WebMæ•°æ®
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            // è§£ç éŸ³é¢‘æ•°æ®
                            const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                            
                            // è½¬æ¢ä¸ºWAVæ ¼å¼
                            const wavBlob = audioBufferToWav(audioBuffer);
                            resolve(wavBlob);
                        } catch (decodeError) {
                            console.error('éŸ³é¢‘è§£ç å¤±è´¥:', decodeError);
                            reject(decodeError);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                    reader.readAsArrayBuffer(webmBlob);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        // å°†AudioBufferè½¬æ¢ä¸ºWAV Blob
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const sampleRate = 16000; // ç›®æ ‡é‡‡æ ·ç‡
            const channels = 1; // å•å£°é“
            
            // é‡é‡‡æ ·åˆ°16kHz
            const resampledBuffer = resampleBuffer(buffer, sampleRate);
            
            // åˆ›å»ºWAVæ–‡ä»¶
            const arrayBuffer = new ArrayBuffer(44 + resampledBuffer.length * 2);
            const view = new DataView(arrayBuffer);
            
            // WAVæ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + resampledBuffer.length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, channels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * channels * 2, true);
            view.setUint16(32, channels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, resampledBuffer.length * 2, true);
            
            // å†™å…¥éŸ³é¢‘æ•°æ®
            let offset = 44;
            for (let i = 0; i < resampledBuffer.length; i++) {
                const sample = Math.max(-1, Math.min(1, resampledBuffer[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        // é‡é‡‡æ ·å‡½æ•°
        function resampleBuffer(buffer, targetSampleRate) {
            if (buffer.sampleRate === targetSampleRate) {
                return buffer.getChannelData(0);
            }
            
            const sampleRateRatio = buffer.sampleRate / targetSampleRate;
            const newLength = Math.round(buffer.length / sampleRateRatio);
            const result = new Float32Array(newLength);
            const offsetResult = 0;
            let offsetBuffer = 0;
            
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                let accum = 0;
                let count = 0;
                
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                    accum += buffer.getChannelData(0)[i];
                    count++;
                }
                
                result[offsetResult] = accum / count;
                offsetResult++;
                offsetBuffer = nextOffsetBuffer;
            }
            
            return result;
        }

        function playAudio(audioUrl) {
            try {
                console.log('æ’­æ”¾éŸ³é¢‘:', audioUrl.substring(0, 50) + '...');
                
                // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘
                if (audioPlayer && !audioPlayer.paused) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
                
                // è®¾ç½®æ–°çš„éŸ³é¢‘æº
                audioPlayer.src = audioUrl;
                
                // æ’­æ”¾éŸ³é¢‘
                const playPromise = audioPlayer.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('éŸ³é¢‘æ’­æ”¾å¼€å§‹');
                        updateVoiceStatus('æ­£åœ¨æ’­æ”¾è¯­éŸ³...');
                    }).catch(error => {
                        console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                        updateVoiceStatus('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
                    });
                }
                
                // ç›‘å¬æ’­æ”¾ç»“æŸäº‹ä»¶
                audioPlayer.onended = () => {
                    console.log('éŸ³é¢‘æ’­æ”¾ç»“æŸ');
                    updateVoiceStatus('æ’­æ”¾å®Œæˆ');
                };
                
            } catch (error) {
                console.error('æ’­æ”¾éŸ³é¢‘æ—¶å‡ºé”™:', error);
                updateVoiceStatus('æ’­æ”¾éŸ³é¢‘å¤±è´¥: ' + error.message);
            }
        }

        function updateVoiceStatus(message) {
            const statusDiv = document.getElementById('voiceStatus');
            const statusText = document.getElementById('voiceStatusText');
            
            if (statusDiv && statusText) {
                statusText.textContent = message;
                statusDiv.style.display = 'block';
                
                // 3ç§’åéšè—çŠ¶æ€
                setTimeout(() => {
                    if (statusDiv.style.display === 'block') {
                        statusDiv.style.display = 'none';
                    }
                }, 3000);
            }
            
            console.log('è¯­éŸ³çŠ¶æ€:', message);
        }

        function getCharacterEmoji(characterId) {
            const emojis = {
                'socrates': 'ğŸ§ ',
                'einstein': 'ğŸ”¬',
                'shakespeare': 'ğŸ“š',
                'harry_potter': 'ğŸ­',
                'confucius': 'ğŸ§ ',
                'marie_curie': 'ğŸ”¬'
            };
            return emojis[characterId] || 'ğŸ¤–';
        }

        // å½•éŸ³æµ‹è¯•åŠŸèƒ½
        async function testRecording() {
            const testBtn = document.querySelector('.voice-test-btn');
            const testResult = document.getElementById('testResult');
            
            try {
                testBtn.textContent = 'ğŸ”„ æµ‹è¯•ä¸­...';
                testBtn.disabled = true;
                testResult.textContent = 'æ­£åœ¨æµ‹è¯•éº¦å…‹é£æƒé™...';
                testResult.style.color = '#007bff';
                
                // 1. æµ‹è¯•éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                testResult.textContent = 'âœ… éº¦å…‹é£æƒé™æ­£å¸¸ï¼Œå¼€å§‹3ç§’å½•éŸ³æµ‹è¯•...';
                
                // 2. è¿›è¡Œ3ç§’å½•éŸ³æµ‹è¯•
                let testMimeType = 'audio/wav';
                if (!MediaRecorder.isTypeSupported(testMimeType)) {
                    testMimeType = 'audio/webm;codecs=opus';
                }
                
                const testRecorder = new MediaRecorder(stream, { mimeType: testMimeType });
                const testChunks = [];
                
                testRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        testChunks.push(event.data);
                    }
                };
                
                testRecorder.onstop = async () => {
                    try {
                        const testBlob = new Blob(testChunks, { type: testMimeType });
                        
                        testResult.textContent = `âœ… å½•éŸ³æµ‹è¯•å®Œæˆï¼
                        ğŸ“Š å½•éŸ³ä¿¡æ¯ï¼š
                        â€¢ æ ¼å¼ï¼š${testMimeType}
                        â€¢ å¤§å°ï¼š${(testBlob.size / 1024).toFixed(1)} KB
                        â€¢ çŠ¶æ€ï¼š${testBlob.size > 1000 ? 'æ­£å¸¸' : 'å¯èƒ½å¤ªå°'}
                        
                        ğŸ’¡ å»ºè®®ï¼š
                        â€¢ å½•éŸ³æ—¶è¯´è¯è¦æ¸…æ™°å“äº®
                        â€¢ é¿å…ç¯å¢ƒå™ªéŸ³
                        â€¢ å½•éŸ³æ—¶é—´å»ºè®®3-8ç§’`;
                        
                        testResult.style.color = testBlob.size > 1000 ? '#28a745' : '#ffc107';
                        
                        // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
                        stream.getTracks().forEach(track => track.stop());
                        
                    } catch (error) {
                        testResult.textContent = `âŒ å½•éŸ³å¤„ç†å¤±è´¥ï¼š${error.message}`;
                        testResult.style.color = '#dc3545';
                    }
                };
                
                // å¼€å§‹å½•éŸ³
                testRecorder.start(100);
                
                // 3ç§’ååœæ­¢
                setTimeout(() => {
                    if (testRecorder.state === 'recording') {
                        testRecorder.stop();
                    }
                }, 3000);
                
                // æ˜¾ç¤ºå€’è®¡æ—¶
                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    testResult.textContent = `ğŸ¤ å½•éŸ³æµ‹è¯•ä¸­... ${countdown}ç§’`;
                    countdown--;
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        testResult.textContent = 'ğŸ”„ å¤„ç†å½•éŸ³æ•°æ®...';
                    }
                }, 1000);
                
            } catch (error) {
                let errorMsg = 'å½•éŸ³æµ‹è¯•å¤±è´¥';
                if (error.name === 'NotAllowedError') {
                    errorMsg = 'âŒ éº¦å…‹é£æƒé™è¢«æ‹’ç»\nè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸éº¦å…‹é£è®¿é—®';
                } else if (error.name === 'NotFoundError') {
                    errorMsg = 'âŒ æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡\nè¯·æ£€æŸ¥è®¾å¤‡è¿æ¥';
                } else if (error.name === 'NotSupportedError') {
                    errorMsg = 'âŒ æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½';
                }
                
                testResult.textContent = errorMsg;
                testResult.style.color = '#dc3545';
            } finally {
                testBtn.textContent = 'ğŸ”§ æµ‹è¯•å½•éŸ³';
                testBtn.disabled = false;
            }
        }

        // å›è½¦å‘é€æ¶ˆæ¯
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('chatModal').addEventListener('click', (e) => {
            if (e.target.id === 'chatModal') {
                closeChat();
            }
        });

        console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œè§’è‰²æ•°é‡:', {{ character_count }});
    </script>
</body>
</html>